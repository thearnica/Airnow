export const Q = (selector) => {  if (typeof selector === 'string') {    return document.querySelector(selector);  } else {    return selector;  }};export const QSA = (selector, parent) => {  if(!selector){    return [];  }  if (typeof selector === 'string') {    var items = (parent || document).querySelectorAll(selector);    return [].concat.apply([], items);  } else {    return [selector];  }};export const waterfall = (fall, cb) => {  function next(result) {    let _cb = function (err) {      if (fall.length === 0) {        cb && cb()      } else {        next.apply(Array.prototype.slice.call(arguments, 1));      }    };    fall.shift().apply(null, Array.prototype.slice.call(arguments, 0).concat([_cb]));  }  next();};export const nothing = () => {};export const inTime = (time, callback) => {  return function (cb) {    callback && callback(null, true);    setTimeout(cb, time)  };};export const withNoTransitionOn = (selector, callback) => {  QSA(selector).forEach(function (item) {    item.classList.add('no-transition');    callback(item);    item.offsetLeft;    item.classList.remove('no-transition');    item.offsetLeft;  });};export const addClassTo = (selector, className, fast) => {  QSA(selector).forEach(function (item) {    if (fast) {      item.classList.add('no-transition');    }    trySeal(item);    item.classList.add(className);    if (fast) {      item.offsetLeft;      item.classList.remove('no-transition');      item.offsetLeft;    }  });};export const removeClassFrom = (selector, className) => {  QSA(selector).forEach(function (item) {    item.classList.remove(className)  });};export const willAddClassTo = (selector, className) => {  return function () {    addClassTo(selector, className);  }};export const willRemoveClassFrom = (selector, className) => {  return function () {    removeClassFrom(selector, className);  }};let RAF;if (window.requestAnimationFrame) {  RAF = window.requestAnimationFrame;} else {  RAF = function (cb) {    setTimeout(cb, 16);  }}// Test via a getter in the options object to see if the passive property is accessedlet supportsPassive = false;try {  let opts = Object.defineProperty({}, 'passive', {    get: function () {      supportsPassive = true;    }  });  window.addEventListener("test", null, opts);} catch (e) {}const PASSIVE_EVENT = supportsPassive ? {passive: true} : false;let WINDOW_SCROLL_TOP = 0;let WINDOW_SCROLL_HEIGHT = 0;export var trySeal = nothing;let objectLOOKUP = {};let sealCounter = 0;export const getID = (item) => {  let id = item.__seal_id;  if (!id) {    item.__seal_id = sealCounter++;  }  return item.__seal_id;};const copyBoundingRect = bb => ({  top: bb.top,  left: bb.left,  bottom: bb.bottom,  right: bb.right,  width: bb.width,  height: bb.height});export const sealPosition = (item) => {  let objectID = getID(item);  objectLOOKUP[objectID] = {    item: item,    position: copyBoundingRect(item.getBoundingClientRect())  };  objectLOOKUP[objectID].position.top += WINDOW_SCROLL_TOP;  return objectLOOKUP[objectID];};export const getBoundingClientRect = (item) => {  let objectID = getID(item);  let object = /*objectLOOKUP[objectID] || */sealPosition(item);  return {    top: object.position.top,// - WINDOW_SCROLL_TOP,    left: object.position.left,// - WINDOW_SCROLL_TOP,    bottom: object.position.bottom,    height: object.position.height  }};export const getScrollTop = () => {  return window.scrollY;};let __scrollHandlers = [];export const attachScrollHandler = (handler) => {  let dispatched = false;  function dispatch() {    WINDOW_SCROLL_TOP = getScrollTop();    WINDOW_SCROLL_HEIGHT = window.innerHeight;    handler();    dispatched = false;  }  function dispatchScroll() {    if (!dispatched) {      dispatched = true;      RAF(dispatch);    }  }  __scrollHandlers.push(dispatchScroll);  window.addEventListener('scroll', dispatchScroll, PASSIVE_EVENT);};export const attachLayoutScrollHandler = (handler) => {    window.addEventListener('scroll', handler, PASSIVE_EVENT);};export const withSeal = (cb) => {  WINDOW_SCROLL_TOP = getScrollTop();  trySeal = sealPosition;  cb();  trySeal = nothing;};